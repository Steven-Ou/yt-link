const { app, BrowserWindow, ipcMain, dialog } = require('electron');
const path = require('path');
const { spawn } = require('child_process');
const { autoUpdater } = require('electron-updater');
const reloader = require('electron-reloader');
const fetch = require('node-fetch');

// Enable hot-reloading in development.
try {
    reloader(module);
} catch (_) {}

let mainWindow;
let pythonProcess = null;

const PYTHON_COMMAND = 'python3'; 
const SCRIPT_PATH = path.join(__dirname, '..', 'service', 'app.py');

function startPythonBackend() {
    // Resolve the python command and script path
    const pythonCommand = process.platform === 'win32' ? 'python' : PYTHON_COMMAND;
    const scriptPath = path.resolve(SCRIPT_PATH);
    
    console.log(`Starting Python backend with command: ${pythonCommand} ${scriptPath}`);

    // Spawn the python process
    pythonProcess = spawn(pythonCommand, [scriptPath]);

    pythonProcess.stdout.on('data', (data) => {
        console.log(`Python Backend: ${data}`);
    });

    pythonProcess.stderr.on('data', (data) => {
        console.error(`Python Backend Error: ${data}`);
    });

    pythonProcess.on('close', (code) => {
        console.log(`Python Backend exited with code ${code}`);
        // Optionally, handle process exit (e.g., restart it)
    });
}


function createWindow() {
    mainWindow = new BrowserWindow({
        width: 1200,
        height: 800,
        webPreferences: {
            preload: path.join(__dirname, 'preload.js'),
            contextIsolation: true,
            nodeIntegration: false,
        },
        icon: path.join(__dirname, '..', 'assets', 'icon.png'),
    });
    
    // Auto-updater configuration
    autoUpdater.setFeedURL({
        provider: 'github',
        owner: 'steven-ou',
        repo: 'yt-link',
    });
    
    // Check for updates
    autoUpdater.checkForUpdatesAndNotify();
    
    // Handle update events
    autoUpdater.on('update-available', () => {
        mainWindow.webContents.send('update-available');
    });
    
    autoUpdater.on('update-downloaded', () => {
        mainWindow.webContents.send('update-downloaded');
    });
    
    ipcMain.on('restart-app', () => {
        autoUpdater.quitAndInstall();
    });

    const isDev = process.env.NODE_ENV !== 'production';

    if (isDev) {
        // In development, load the Next.js development server.
        // Make sure the port matches what `npm run start:frontend` is using.
        mainWindow.loadURL('http://localhost:3001');
        mainWindow.webContents.openDevTools();
    } else {
        // In production, load the static HTML file that was generated by the 'next build' command.
        const indexPath = path.join(__dirname, 'out', 'index.html');
        mainWindow.loadFile(indexPath);
    }

    mainWindow.on('closed', function () {
        mainWindow = null;
    });
}

// IPC COMMUNICATION -- Handles all API requests from the UI (renderer process) to the Python backend.
async function handleJobRequest(endpoint, body) {
    const url = `http://127.0.0.1:8080/${endpoint}`;
    console.log(`[main.js] Attempting to POST to: ${url}`);
    console.log(`[main.js] With body: ${JSON.stringify(body)}`);

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(body),
        });

        console.log(`[main.js] Received response status: ${response.status}`);

        if (!response.ok) {
            const errorText = await response.text();
            console.error(`[main.js] HTTP error! Status: ${response.status}, Body: ${errorText}`);
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        console.log('[main.js] Successfully got JSON response from Python:', data);
        return data;
    } catch (error) {
        console.error('[main.js] CRITICAL: Failed to communicate with Python backend. Full error:');
        console.error(error);
        return { error: 'Failed to get Job ID from server.' };
    }
}


app.on('ready', () => {
    startPythonBackend();
    createWindow();
});

app.on('window-all-closed', function () {
    if (process.platform !== 'darwin') {
        app.quit();
    }
});

app.on('before-quit', () => {
    if (pythonProcess) {
        console.log('Killing Python backend process...');
        pythonProcess.kill();
    }
});


app.on('activate', function () {
    if (mainWindow === null) {
        createWindow();
    }
});

// IPC handler for starting a job
ipcMain.handle('start-job', async (event, endpoint, body) => {
    console.log(`[main.js] Received 'start-job' IPC call for endpoint: ${endpoint}`);
    return await handleJobRequest(endpoint, body);
});

// IPC handler for checking job status
ipcMain.handle('check-status', async (event, jobId) => {
    try {
        const response = await fetch(`http://127.0.0.1:8080/job-status/${jobId}`);
        const data = await response.json();
        return data;
    } catch (error) {
        console.error(`Error checking status for job ${jobId}:`, error);
        return { error: 'Failed to get job status.' };
    }
});

// IPC handler for opening a file dialog
ipcMain.handle('open-file-dialog', async () => {
    const result = await dialog.showOpenDialog(mainWindow, {
        properties: ['openDirectory']
    });
    return result.filePaths[0];
});
